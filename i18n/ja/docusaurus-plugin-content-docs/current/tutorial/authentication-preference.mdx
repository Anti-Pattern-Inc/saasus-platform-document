---
sidebar_position: 3
title: "認証の設定"
slug: "authentication-preference"
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

### SaaS 利用者テナントの作成

ではまず、サンプルアプリケーション用に、テナントを２つ作成してみましょう。

サイドメニューの「テナント管理」をクリックします。

![01](/ja/img/tutorial/authentication-preference/authentication-preference-01.png)

「テナント作成」ボタンをクリックしてポップアップを表示します。

テナント名・代表者ユーザーの追加・代表者メールアドレス・代表者の仮パスワード、その他にGuidesでご紹介している[テナントに追加属性を定義する](../saas-development-console/declare-additional-attribute-to-tenant)で追加したテナント属性が表示されます。


１つ目

- 名前：テナントサンプルその１
- メモ：テナント属性で定義した属性情報となり、自由に設定可能となります
- 代表ユーザーの追加：新規でユーザーを作成
- 代表者メールアドレス： [saasus-sample-tenant1@example.com](mailto:saasus-sample-tenant1@example.com)
- 代表者のパスワード： G@2qYPQq などパスワード要件を満たすもの

![02](/ja/img/tutorial/authentication-preference/authentication-preference-02.png)

２つ目

- 名前：サンプルアプリテナント２
- メモ：テナント属性で定義した属性情報となり、自由に設定可能となります
- 代表ユーザーの追加：新規でユーザーを作成
- 代表者メールアドレス： [saasus-sample-tenant2@example.com](mailto:saasus-sample-tenant2@example.com)
- 代表者のパスワード： irG_l88r などパスワード要件を満たすもの

（特に決まりではないので、他の値を入れていただいても OK です）

![03](/ja/img/tutorial/authentication-preference/authentication-preference-03.png)

これで、テナントの作成と、そのテナントに属する各１名のユーザーが作成されました。

### SaaS 利用ユーザーの作成

では、ユーザー一覧を見てみましょう。サイドメニューから「ユーザー管理」をクリックします。

先ほど作成したユーザーが、各テナント、各環境の admin（SaaS 管理者）の役割として登録されています。

![04](/ja/img/tutorial/authentication-preference/authentication-preference-04.png)

SaaSus Platform では、SaaS 利用者のテナントに「環境」という概念が利用できます。

たとえば、Stripe のように API をメインで使う SaaS では、SaaS 利用者は連携のテストや開発時用の環境が必要になります。<br/>
これらを行うために 開発環境 という環境を使い、実際の運用では 本番環境 という環境を使うというように SaaS 管理者は複数の環境を定義することができるようになっています。

![05](/ja/img/tutorial/authentication-preference/authentication-preference-05.png)

:::info
SaaS によっては、複数環境が不要な場合もありますので、単一環境を使う場合は 本番環境 だけ意識していただければ大丈夫です。
:::

では、各テナントごとに１名づつユーザーを登録してみましょう。

右上の「ユーザ作成」ボタンをクリックし、ポップアップを出します。

とりあえず、4 名登録してみましょう。

メールアドレス: [user1-1@example.com](mailto:user1-1@example.com)  
パスワード： パスワード要件を満たすもの  
テナント： テナントサンプルその１  
ユーザ名： ユーザー1-1

![06](/ja/img/tutorial/authentication-preference/authentication-preference-06.png)

メールアドレス: [user1-2@example.com](mailto:user1-2@example.com)  
パスワード： パスワード要件を満たすもの  
テナント： テナントサンプルその１  
ユーザ名： ユーザー1-2

メールアドレス: [user2-1@example.com](mailto:user2-1@example.com)  
パスワード： パスワード要件を満たすもの  
テナント： サンプルアプリテナント２  
ユーザ名： ユーザー2-1

メールアドレス: [user2-2@example.com](mailto:user2-2@example.com)  
パスワード： パスワード要件を満たすもの  
テナント： サンプルアプリテナント２  
ユーザ名： ユーザー2-2

![07](/ja/img/tutorial/authentication-preference/authentication-preference-07.png)

4 名追加でユーザ登録できました。

これらのユーザーに役割を追加することもできます。

:::info
役割の追加方法は下記ページを確認してください。<br/>
[ユーザーに役割を追加](../saas-operation-console/adding-role-to-user)
:::

:::info
以降の手順ではプログラミングの知識が必要となります。
:::

### 認証後の遷移先 URL の設定

設定したドメイン名をベースにして、SaaSus Platform はログイン画面を生成します。<br/>
ログイン後、SaaS 側に認証情報を引き継ぎます。この引き継ぎ先の SaaS の URL を、Callback URL として登録する必要があります。

サイドメニューから「認証後遷移先」をクリックし、Callback URL 設定画面を表示します。

通常は、提供している SaaS の URL をベースに Callback URL を設定します。<br/>
ただし、今回はサンプルアプリケーションをローカルで動かすため、以下のように設定します。

PHPの場合　[http://localhost/callback](http://localhost/callback)

Next.jsの場合　[http://localhost:3000/callback](http://localhost:3000/callback)

![08](/ja/img/tutorial/authentication-preference/authentication-preference-08.png)

### 認証モジュールの組み込み

次に、 SaaSus Platform の認証モジュールを組み込みます。

今回のアプリケーションでは、すべての URI のルートに認証を必要とします。認証されていない場合には、アプリケーションが利用できない仕様にします。

Next.jsのサンプルアプリで動作確認を行なっている場合は、Callbackを受け取るページの作成を行います。

front/src/pages/callback/index.tsx を作成し、以下を追加してください。

<Tabs>
<TabItem value="typescript" label="Typescript">

```typescript
import Container from '@mui/material/Container'
import { useRouter } from 'next/router'
import { useEffect } from 'react'
import axios from '@/lib/axios'

const Callback = () => {
  const router = useRouter()
  const query = router.query
  const code = query.code as string

  const fetchAuthCredentials = async () => {
    const res = await axios.get(`/api/callback?code=${code}`)
    // 渡ってきたJWTをLocal Storageに保存する
    const idToken = res.data.id_token as string
    localStorage.setItem('SaaSusIdToken', idToken)
    router.replace('/board')
  }

  useEffect(() => {
    if (router.isReady) {
      if (code) {
        fetchAuthCredentials()
      }
    }
  }, [query, router])

  return <Container disableGutters></Container>
}

export default Callback
```

</TabItem>
</Tabs>

ここでは、渡ってきた一時コードを元にAPIから認証情報を取得し、id_token をブラウザのlocal storageに格納して、boardページにリダイレクトしています。

次に、この保存したトークンを後ほどAPIコール時にヘッダにつけるようにします。

front/src/pages/board/index.tsx を編集していきます。

<Tabs>
<TabItem value="typescript" label="Typescript">

```typescript
import { MessageBoard } from '@/components/MessageBoard'
import { formValueFormat } from '@/const/formTemplate'
import Container from '@mui/material/Container'
import useSWR, { useSWRConfig } from 'swr'
import axios from '@/lib/axios'

const Board = () => {
 const { mutate } = useSWRConfig()
 const fetcher = (url: string) => {
   // Local StorageからJWTを取得し、Bearer tokenとしてヘッダにつけてAPIコールする
   const token = localStorage.getItem('SaaSusIdToken')
   if (!token) return ''
   return axios
     .get(url, {
       headers: {
         Authorization: `Bearer ${token}`,
       },
     })
     .then((res) => res.data)
 }
 const { data: tenant_name, error: tenant_error } = useSWR(
   `/api/tenant`,
   fetcher
 )
 const { data: messages, error } = useSWR(`/api/board`, fetcher, {
   refreshInterval: 5000,
 })
 if (error || tenant_error) return <div>failed to load</div>
 if (!messages || !tenant_name) return <div>loading...</div>

 const handleSubmit = async (value: string) => {
   const formValue = { ...formValueFormat, message: value }
   // 再検証をせずに直ちにローカルデータを更新
   mutate('/api/board', [...messages, formValue], false)
   // 更新するために API にリクエストを送信
   // Local StorageからJWTを取得し、Bearer tokenとしてヘッダにつけてAPIコールする
   const token = localStorage.getItem('SaaSusIdToken')
   await axios.post('/api/post', formValue, {
     headers: {
       Authorization: `Bearer ${token}`,
     },
   })
 }

 return (
   <Container disableGutters>
     <MessageBoard
       messages={messages}
       tenant_name={tenant_name}
       onSubmit={handleSubmit}
     />
   </Container>
 )
}

export default Board
```

</TabItem>
</Tabs>

今回はAPIコールしている部分が少ないので簡易的にaxiosのコール時に直接指定してますが、実施にはミドルウェアを使うなどで共通化するのが良いかと思います。

次にバックエンドの調整を行います。

現状は、

PHPの場合は、api/routes/web.php

Next.jsの場合は、api/app.ts

にて認証機能が利用されているので、SaaSus の認証機能に置き換えます。

この部分

```mdx-code-block
<Tabs>
<TabItem value="php" label="PHP" default>
```

```php
Route::middleware('auth')->group(function () {
   Route::get('/', function () {
       return view('welcome');
   });
   Route::get('/dispatch', 'App\Http\Controllers\DispatchController@index')->name('dispatch');
   Route::get('/board', 'App\Http\Controllers\MessageController@index')->name('board');
   Route::post('/post', 'App\Http\Controllers\MessageController@post')->name('post');
});

require __DIR__ . '/auth.php';
```

```mdx-code-block
</TabItem>
<TabItem value="nodejs" label="Node.js">
```

```js
app.use(
  session({
    secret: "secret",
    resave: false,
    saveUninitialized: false,
  })
);
app.use(passport.initialize());
app.use(passport.session());
```

```mdx-code-block
</TabItem>
</Tabs>
```

を

```mdx-code-block
<Tabs>
<TabItem value="php" label="PHP" default>
```

```php
// Route::middleware('auth')->group(function () {
//     Route::get('/', function () {
//         return view('welcome');
//     });
// SaaSus SDK標準のAuth Middlewareを利用する
Route::middleware(\AntiPatternInc\Saasus\Laravel\Middleware\Auth::class)->group(function () {
   Route::get('/dispatch', 'App\Http\Controllers\DispatchController@index')->name('dispatch');
   Route::get('/board', 'App\Http\Controllers\MessageController@index')->name('board');
   Route::post('/post', 'App\Http\Controllers\MessageController@post')->name('post');

   Route::redirect('/', '/board');
});

// require __DIR__ . '/auth.php';
```

```mdx-code-block
</TabItem>
<TabItem value="nodejs" label="Node.js">
```

```js
import { AuthMiddleware } from "saasus-sdk";
...
// app.use(
//   session({
//     secret: "secret",
//     resave: false,
//     saveUninitialized: false,
//   })
// );
app.use(
  ["/chat", "/api/board", "/api/post", "/api/plan", "/api/tenant"],
  AuthMiddleware
);
// app.use(passport.initialize());
// app.use(passport.session());
```

```mdx-code-block
</TabItem>
</Tabs>
```

このようにします。

そして、認証画面からのコールバックの受口を用意します。先ほど SaaSus 開発コンソールでコールバック先を 

PHPの場合は、[http://localhost/callback](http://localhost/callback) 

Next.jsの場合は、[http://localhost:3000/callback](http://localhost:3000/callback) 

と定義したので、 /callback で受け取れるようにします。

PHPの場合はおなじく、 api/routes/web.php の最後の行に以下を追加します。

Next.jsの場合は、api/routes/callback.tsを作成して以下を記載します。

```mdx-code-block
<Tabs>
<TabItem value="php" label="PHP" default>
```

```php
// SaaSus SDK標準のCallback Controllerを利用して、JWTをCookieやLocal Storageに入れる
Route::get('/callback', 'AntiPatternInc\Saasus\Laravel\Controllers\CallbackController@index');
```

```mdx-code-block
</TabItem>
<TabItem value="nodejs" label="Node.js">
```

```js
import express from "express";
const router = express.Router();
import { CallbackRouteFunction } from "saasus-sdk";

router.get("/", CallbackRouteFunction);

export { router };
```

```mdx-code-block
</TabItem>
</Tabs>
```

さらに、SaaSus SDK が提供する View を使えるように 

PHPの場合は、api/config/view.php にパスを追加します。

Next.jsの場合は、api/views/callback.ejsを作成し下記を記載します。

```mdx-code-block
<Tabs>
<TabItem value="php" label="PHP" default>
```

```php
   'paths' => [
       resource_path('views'),
       # ↓この行を追加：SaaSus SDKが提供するViewのディレクトリ
       resource_path('../vendor/saasus-platform/saasus-sdk-php/src/Laravel/Views'),
   ],
```

```mdx-code-block
</TabItem>
<TabItem value="nodejs" label="Node.js">
```

```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Auth Callback</title>
  </head>

  <body>
    <script>
      location.href = "/chat";
    </script>
  </body>
</html>
```

```mdx-code-block
</TabItem>
</Tabs>
```

ここまで設定すると、 アプリケーションの Controller にたどり着いた時点で、SaaSus Platform で設定した認証情報が request の一部として渡ってくるようになります。

PHPの場合は、api/app/Http/Controllers/MessageController.php の index に Request の引数を追加し、 dd を使って $request に userinfo が入っているか確認してみましょう。

Next.jsの場合は、api/controllers/chat.ts の getChats に Request の引数を追加し、console.logを使って req に userinfo が入っているか確認してみましょう。

```mdx-code-block
<Tabs>
<TabItem value="php" label="PHP" default>
```

```php
   public function index(Request $request)
   {
       // SaaSus Platformからユーザ情報が渡ってきているかを確認する
       dd($request->userinfo);
```

```mdx-code-block
</TabItem>
<TabItem value="nodejs" label="Node.js">
```

```js
const getChats = async (req: Request, res: Response) => {
  // SaaSus Platformからユーザ情報が渡ってきているかを確認する
  console.log(req.userinfo);
```

```mdx-code-block
</TabItem>
</Tabs>
```

ここまでで連携の基本ができました。

実際に SaaSus Platform からログインして動作を確認します。

### SaaSus SDK 組み込みの確認

SaaSus Platform で作成したログイン画面を表示します。

[https://auth.sample.saasus.jp](https://auth.sample.saasus.jp) など、ご自身で設定したドメインのログイン画面を表示してください。

![09](/ja/img/tutorial/authentication-preference/authentication-preference-09.png)

先ほど作成したユーザのメールアドレスとパスワードでログインすると、Callback URL で設定した URL に、認証情報とともにリダイレクトされます。

たとえば、 [user1-1@example.com](mailto:user1-1@example.com) でログインしてみましょう。

実際に先ほどのコードが動作すると、ログイン後にこのような表示になるはずです。

```php
array:3 [▼
  "email" => "user1-1@example.com"
  "id" => "f6a02019-1306-431f-b93d-3a756b312481"
  "tenants" => array:1 [▼
    0 => array:7 [▼
      "back_office_staff_email" => "saasus-sample-tenant1@example.com"
      "completed_sign_up" => true
      "envs" => array:1 [▼
        0 => array:3 [▼
          "id" => 1
          "name" => "dev"
          "roles" => array:1 [▼
            0 => array:2 [▼
              "display_name" => "一般利用者"
              "role_name" => "user"
            ]
          ]
        ]
      ]
      "id" => "7b639774-6fba-4b26-b580-f3d755876a4b"
      "name" => "テナントのサンプルその１"
      "plan_id" => "bc011444-a9f1-41c0-8251-bc8928b09ee7"
      "user_attribute" => array:1 [▼
        "username" => "user1-1"
      ]
    ]
  ]
]
```

アプリケーション側で、先ほど SaaSus Platform で設定したユーザ情報、テナント情報が取得できているのがわかります。

リダイレクト先の URL は、今回 SaaSus SDK 標準の Callback 処理で受けるようになっており([http://localhost/callback](http://localhost/callback))、その処理の中で ブラウザの Local Storage や Cookie の中に認証情報を記憶します。

そして、 SaaSus SDK の Auth Middleware で、SaaSus Platform を利用し認証情報を検証しユーザ情報を取得して Request オブジェクトに詰めます。

そのあと、アプリケーションのコントローラに処理が移るので、この時点ですでにアプリケーションはログインした人の情報を持っていることになります。

では、この情報を使って、掲示板アプリケーションをマルチテナント対応にしてみましょう。

:::info
自動生成されたログイン画面はサービス名やアイコンを表示したり、利用規約やプライバシーポリシーのリンクを設定することができます。<br/>
設定方法は、[ログイン画面など認証系画面のカスタマイズ](../saas-development-console/authorization-screen-customize)で確認してください。
:::

### サンプルアプリケーションのマルチテナント化

PHPの場合は、api/app/Http/Controllers/MessageController.php が

Next.jsの場合は、api/controllers/chat.ts が

メインの処理なので、ここにマルチテナント対応にするための処理を入れてみましょう。

まず、表示の部分を変更します。  
下記の部分をまるごと書き換えてみましょう。

```mdx-code-block
<Tabs>
<TabItem value="php" label="PHP" default>
```

```php
   public function index(Request $request)
   {
       // $request->userinfo に各種ユーザ情報、テナント情報が入ってくるので、それを使う
       $messages = Message::where('tenant_id', $request->userinfo['tenants'][0]['id'])->get();
       return view('messageBoard.index', ['messages' => $messages, 'plans' => $this::PLANS, 'tenant_name' => $request->userinfo['tenants'][0]['name']]);
   }
```

```mdx-code-block
</TabItem>
<TabItem value="nodejs" label="Node.js">
```

```js
const getChats = async (req: Request, res: Response) => {
  try {
    const messages = await db.Messages.findAll({
      where: {
        tenant_id: req.userInfo?.tenants[0].id,
      },
    });
    res.render("chat", {
      messages: messages,
      plans: PLANS,
      tenant_name: TENANT_NAME,
    });
  } catch (error) {
    console.error(error);
    res.redirect("/chat");
  }
};
```

```mdx-code-block
</TabItem>
</Tabs>
```

このようにして、渡ってきたテナント ID をもとに DB を検索するようにします。

次に投稿の部分です。

```mdx-code-block
<Tabs>
<TabItem value="php" label="PHP" default>
```

```php
   public function post(Request $request)
   {
       $validated = $request->validate([
           'message' => 'required|max:255'
       ]);

       // $request の userinfo から各種情報を取得し、判断に使う
       $message = Message::create([
            'tenant_id' => $request->userinfo['tenants'][0]['id'],
            'user_id' => $request->userinfo['tenants'][0]['user_attribute']['username'],
            'message' => $request->message,
        ]);

       $request->session()->regenerateToken();
       return redirect()->route('board');
   }
```

```mdx-code-block
</TabItem>
<TabItem value="nodejs" label="Node.js">
```

```js
const postChats = async (req: Request, res: Response) => {
  const mes = req.body.message;
  const tenantId = req.userInfo?.tenants[0].id || "";
  const userName =
    req.userInfo?.tenants[0].user_attribute.username || "テストユーザー";
  try {
    await db.Messages.create({
      tenant_id: tenantId,
      user_id: userName,
      message: mes,
    });
  } catch (error) {
    console.error(error);
  }
  res.redirect("/chat");
};
```

```mdx-code-block
</TabItem>
</Tabs>
```

渡ってきたユーザ属性をもとに、テナント ID、ユーザ名をセットで格納します。

画面表示の部分も、ユーザ ID を表示するようにしてみます。

PHPの場合は、api/resources/views/messageBoard/index.blade.php を編集します。

32 行目あたりの、この $message->user->name の部分を $message->user_id に変更します。

修正前：

```blade
                   <div class="mt-4">
                       <p>
                           {{ $message->user->name }}
                           <span class="text-xs text-gray-500">
                               {{ $message->created_at->format('Y/m/d H:i') }}
                           </span>
                       </p>
```

修正後：

```blade
                   <div class="mt-4">
                       <p>
                           {{ $message->user_id }}
                           <span class="text-xs text-gray-500">
                               {{ $message->created_at->format('Y/m/d H:i') }}
                           </span>
                       </p>
```

Next.jsの方は修正不要です。

これでマルチテナント対応ができました。

では、早速ログインして試してみましょう。

先ほどと同じように、SaaSus Platform で作成したログイン画面からログインを行います。

ログインすると、テナント名が先ほど SaaS 開発コンソールで設定したものに変わっているのが確認できます。

![10](/ja/img/tutorial/authentication-preference/authentication-preference-10.png)

まだデータが無いので、いくつか投稿をしてみましょう。

![11](/ja/img/tutorial/authentication-preference/authentication-preference-11.png)

ユーザ名も表示されていることが確認できました。

では、もう一度ログイン画面に戻り、 [user1-2@example.com](mailto:user1-2@example.com) でログインして、いくつか投稿してみましょう。

![12](/ja/img/tutorial/authentication-preference/authentication-preference-12.png)

当然画面に反映されます。

では、もうひとつのテナントのユーザ、 [user2-1@example.com](mailto:user2-1@example.com) でログインしてみましょう。

![13](/ja/img/tutorial/authentication-preference/authentication-preference-13.png)

テナント名の表示が変わり、内容が空になっていることが確認できます。

自分のテナントの情報にしかアクセスできないことが確認できました。

では、同じようにいくつか投稿をした後に、 [user2-2@example.com](mailto:user2-2@example.com) でログインし、同一テナントの情報が表示できることを確認します。

![14](/ja/img/tutorial/authentication-preference/authentication-preference-14.png)

このように、テナントごとの分離が完了しました。

今回の分離方式としては、プール型モデルで同一 DB 内での分離を行いシンプルな方式でテナント分離を行いました。スキーマ分離、データベース分離など、要件に応じてテナント分離の方式を選択する場合においても、同様に SaaSus SDK を利用してテナント情報を取得し実装することができます。

テナント分離ができたので、今度は料金関係の機能の実装をしてみましょう。

料金設定（プライシング）、利用量計測（メータリング）、請求（ビリング）の第一歩を実装してみます。請求においては Stripe という請求 SaaS を利用します。Stripe を使わない場合は、請求の部分はスキップしてください。